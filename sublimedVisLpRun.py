#! /usr/bin/env python

##############################################################
#  Levenberg-Marquardt least squares coma visibility fitter. #
#  Finds best-fitting SUBLIMED1D visibility model, based on  # 
#  channel-by-channel fit to Real visibility amplitudes,     # 
#  sampled using Loomis vis-sample.                          #
#  Based on sublimed1dVisFit2Spec.py                         #
#  Radial temperature curve is supplied to sublimed1d via    # 
#  T_r.txt file, generated by interpolating and smoothing the#
#  supplied T(r) points in the input file.  T_r.txt will only#
#  be created if it does not already exist,                  #
#  The SUBLIME model is automatically convolved to the same  #
#  spectral resolution and binning as the observed data;     #
#  for a single-channel ms, the model is simply averaged.    #
#  This version is for a single species, and allows a        #
#  daughter with optimizable parent scale length lp.         #
##############################################################

import os,sys
import numpy as np
from pymodules.mpfit import mpfit
from pymodules.lime import writeLimeInputMartin
from scipy.interpolate import interp1d
from scipy.stats import chi2
import pylab as plt
from pymodules.imtools import sigClip,pbMultiply
from pymodules import io
from astropy.convolution import convolve,Gaussian1DKernel,Box1DKernel
from pymodules.vis_sample.file_handling import import_data_ms
import pymodules.vis_sample as vs
import casatools
from astropy.io import fits

import pdb

deltachisq = 6.63
chisqs=[]
dabunds=[]
dabunderrs=[]
lp1s=[]
lp2s=[]
gammas=[]

if len(sys.argv) != 2: sys.exit("Usage: sublimed1dVisFit.py sublimed1dVisFit.par")

#  Chi-squared tolerance between successive iterations
#ftol = 1.0e-6
chisqtol = 0.1
#  Parameter value tolerance between successive iterations
xtol = 1.0e-3

c = 2.99792458e8

#####################################################################
# Function to interface with MPFIT and return normalised residuals  #
#####################################################################
def getChisq(p, fjac=None, functkw=None):
     
   global gamma,lp1,lp2,Q1,Q2,coneSolidAng  
   
   getChisq.nCalls += 1
     
   rresiduals=[]
   model=[]
   Tvals1=[]
   
   p=p.tolist()
   print(p)
    
#  Other parameters for this run            
   Qratio,abund,vexp1,vexp2,dabund,doppler,openAngle = p

   coneSolidAng = 2*np.pi*(1-np.cos(np.pi*openAngle/180.))
   Q2 = Q/(Qratio*coneSolidAng/(4*np.pi) + (1-coneSolidAng/(4*np.pi))) 
   Q1=Q2*Qratio

   # If requested, make both Lp values consistent with a common photolysis rate, despite different vexps
   lp1 = abs(lp)
   lp2 = abs(lp)
   if (reScaleLp and (lp1 > 0)):
      gamma = vexp1/lp1
      lp2 = vexp2/gamma
   writeLimeInputMartin.sublimedModelTvarDP(Q1,Q2,abs(abund),vexp1,vexp2,abs(lp1),abs(lp2),abs(dabund),rNuc,betamain,betamol,rH,delta,spec,chwid,nchan,lamFile,pumpFile,popFile,fitsFile,TrFile1,TrFile2,f0,collPartId,modelFile,xne,colliScale,doppler,lteonly,useEP,npix,imgres,nTpts,openAngle,pIntensity,phase,psAng,xoff,yoff)
   
   os.system("sublimed2traj %s" % (modelFile)) 
   
#  Multiply by primary beam   
   PBFits = fitsFile[:-5] + '_PB.fits'
   pbMultiply(fitsFile,PBFits,hpbw)
  
   model_vis = vs.vis_sample(imagefile=PBFits,uu=data_vis.uu,vv=data_vis.vv,mod_interp=False)

# Rebin the spectral axis
   hdu = fits.open(PBFits)
   cubeheader = hdu[0].header
   # Generate model frequency grid
   specx = (1-((np.arange(cubeheader['NAXIS3']) - cubeheader['CRPIX3'] +1) * cubeheader['CDELT3'] + cubeheader['CRVAL3'])/c) * cubeheader['RESTFRQ'] + deltaf
   mrecb=[]
   mimcb=[]
   for i in range(len(model_vis)):
      if rez > 0:
#  Convolve the model spectrum to the required resolution
         mrec=convolve(np.real(model_vis)[i], specKernel)
         mimc=convolve(np.imag(model_vis)[i], specKernel)
      else:
         mrec = np.real(model_vis)[i]
         mimc = np.imag(model_vis)[i]
      mrecI=interp1d(specx,mrec)
      mimcI=interp1d(specx,mimc)
      mrecb.append(mrecI(obsFreqs))
      mimcb.append(mimcI(obsFreqs))
   mrecb=np.asarray(mrecb)
   mimcb=np.asarray(mimcb)
   
#  Subtract model from observation to generate residuals  
   residuals = np.ravel((re - mrecb)/rms[:,np.newaxis])
   imResids = np.ravel((im - mimcb)/rms[:,np.newaxis])
   residuals = np.concatenate((residuals,imResids))
   
#  If total power data was supplied, generate the TP model spectrum and concatenate the residuals
   if doTP:
      mtpy = np.sum(hdu[0].data[0],axis=(1,2))
      mtpyc=convolve(mtpy, specKernel)
      mtpcI=interp1d(specx,mtpyc)
      mtpycb=mtpcI(obsFreqs)
      tpResids = (tpy - mtpycb) / tpe
      residuals = np.concatenate((residuals,tpResids))
   
   print("Chisq (%d) = " % (getChisq.nCalls), np.sum(residuals**2),"\n")
   
   status=0
   
   return ([status,residuals])

###################################################################
#  MAIN PROGRAM                                                   #
###################################################################

# Load input parameters
exec(compile(open(sys.argv[1], "rb").read(), sys.argv[1], 'exec'))

# Load the observed visibility data from CASA ms
data_vis=import_data_ms(obsVis)
re=np.real(data_vis.VV)
im=np.imag(data_vis.VV)
obsFreqs = np.squeeze(data_vis.freqs)

#Set MPFIT chi square tolerance to 0.1, regardless of the number of degree of freedom
ftol = chisqtol/(re.size + im.size)

# Get the sigma value for each visibility point from the .ms weight column
sigmas = (1./data_vis.wgts)**0.5
rms = sigmas

if ('imgRMS' in globals()):
   rms = sigmas*0. + (imgRMS * re.shape[0]**0.5)  # Noise per visibility based on corresponding image RMS - Overrides visibility sigma values if present
if ('visRMS' in globals()):
   rms = sigmas*0. + visRMS  #Overrides imgRMS and visibility sigma values if present

if ('colliScale' not in  globals()):
   colliScale = 1

# Load the TP data (if supplied)
ntp = 0
doTP = False
if('tpData' in globals()):
   doTP = True
   otpx,otpy,otpe = np.loadtxt(tpData,unpack=True, ndmin=2)
   ntp = len(otpx)
   #Interpolate the TP data to ensure they're on the same frequency axis as the cross-correlations
   tpModel = interp1d(1e9*otpx,otpy,fill_value=0,bounds_error=False)
   tpeModel = interp1d(1e9*otpx,otpe,fill_value='extrapolate',bounds_error=False)
   tpy = tpModel(obsFreqs)
   tpe = tpeModel(obsFreqs)

nTpts = np.genfromtxt(TrFile1).shape[0]

# Determine whether the input image has multiple channels and set the number of model channels accordingly
if(len(data_vis.freqs) > 1):
   obsFreqs = np.squeeze(data_vis.freqs)
   f0 = 0.5*(obsFreqs[-1]+obsFreqs[0])
   nchan = (int)(abs(obsFreqs[-1]-obsFreqs[0]) * c / f0 / chwid) + 2
   binWidth = abs(((obsFreqs[1]-obsFreqs[0]) * c / f0))
   if rez > 0:
      rezchans = rez/chwid
      if kernel == 'box':
         psfShape = 1
         specKernel = Box1DKernel(int(round(rezchans)))
      elif kernel == 'gauss':
         psfShape = 2
         specKernel = Gaussian1DKernel(rezchans/2.3548)
   else:
      psfShape = 0
else:
   obsFreqs = data_vis.freqs[0]
   f0 = obsFreqs[0]
   ms=casatools.ms()
   ms.open(obsVis)
   binWidth = abs(ms.getspectralwindowinfo()['0']['ChanWidth']) * c / f0
   ms.close()
   nchan = (int)(binWidth  / chwid) + 2
   # Tweak the model velocity range so that it exactly matches the observed channel width
   chwid = binWidth / nchan
   rez = binWidth
   rezchans = nchan
   psfShape = 1
   kernel = 'box'
   specKernel = Box1DKernel(int(round(rezchans)))


# If the observations are Doppler shifted (in contrast to the model), then we need to work out how much to shift the model (deltaf) so that the grids can be lined up
deltaf = 0.
if('forcef0' in globals()):
    deltaf = f0-forcef0
    f0 = forcef0

# Note: Model spectral axis will be centered on the central channel and no transition index is needed 
print("INFO: The observed spectrum is on a frequency axis (centered on %f). The SUBLIME model will have %d channels." %(f0,nchan))
nBins = len(data_vis.freqs)

# Model sampling warnings
if rez != 0:
   if rez/chwid < 2:
      print("WARNING: The model channel width is more than half the spectral resolution --> the spectral convolution kernel will be poorly sampled")

parinfo=[]


for i in range(len(p0)):
   parinfo.append({'value':p0[i], 'fixed':pfix[i], 'limited':[0,0], 'limits':[0.,0.], 'relstep':0.1})

# Qratio limits
parinfo[0]['limited'] = [1,1]
parinfo[0]['limits'] = [0.1,10.0]

# vexp1 limits
parinfo[2]['limited'] = [1,1]
parinfo[2]['limits'] = [0.1,2.0]

# vexp2 limits
parinfo[3]['limited'] = [1,1]
parinfo[3]['limits'] = [0.1,2.0]

# dAbund limits
parinfo[4]['limited'] = [1,1]
parinfo[4]['limits'] = [-1.,1.]

# doppler limits
parinfo[5]['limited'] = [1,1]
parinfo[5]['limits'] = [0.00,0.5]

# Cone angle limits
parinfo[6]['limited'] = [1,1]
parinfo[6]['limits'] = [5.,150.]
del(parinfo[6]['relstep'])
parinfo[6]['step'] = 10.0

print("Starting Lp run...")

for lp in Lps:
    getChisq.nCalls = 0
    print("\n***** Lp = "+str(lp))
    print("Starting MPFIT...")
    result = mpfit(getChisq, p0, parinfo=parinfo, xtol=xtol,ftol=ftol)
    
    #  Exit and print any error messages
    print('MPFIT exit status = ', result.status)
    if (result.status <= 0): 
        print('MPFIT', result.errmsg)
        sys.exit(result.status)

    #  Get final parameters
    pars=result.params.tolist()
    perrors=result.perror.tolist()
    
    Qratio,abund,vexp1,vexp2,dabund,doppler,openAngle = pars  
    sigma_Qratio,sigma_abund,sigma_vexp1,sigma_vexp2,sigma_dabund,sigma_doppler,sigma_openAngle = perrors
    
    # Reduced chi square
    DOF = len(np.ravel(re))+ntp-(len(p0)-sum(pfix))
    print('\nReduced Chisq X_r = %.4f'% (float(result.fnorm) / DOF))
    print('P (probability that model is different from data due to chance) = %.3f' % chi2.sf(result.fnorm,DOF))

    print('\nBest-fit parameters and 1-sigma covariance errors:')
    print('Qratio = %8.3e +- %8.3e' %(Qratio, sigma_Qratio))
    print('Abund. = %8.3e +- %8.3e' %(abs(abund), sigma_abund))
    print('v_exp1 = %.3f +- %.3f km/s' %(vexp1,sigma_vexp1))
    print('v_exp2 = %.3f +- %.3f km/s' %(vexp2,sigma_vexp2))
    print('L_p1 = %.1f' %(lp1))
    print('L_p2 = %.1f' %(lp2))
    if(lp1>0):
      print('Gamma_p = %8.3e s^-1' %(vexp1/lp1))
      gammas.append(gamma)
    else:
      gammas.append(1e30)
    print('dAbund. = %8.3e +- %8.3e' %(abs(dabund),sigma_dabund))
    print('doppler = %.3f +- %.3f km/s' %(doppler, sigma_doppler))
    print('openAngle = %.1f +- %.1f deg.' %(openAngle, sigma_openAngle))
    print('T_kin = '+TrFile1+' + '+TrFile2)
    chisqs.append(result.fnorm)
    dabunds.append(dabund)
    dabunderrs.append(sigma_dabund)
    lp1s.append(lp1)
    lp2s.append(lp2)

io.write6col(lp1s,lp2s,gammas,chisqs,dabunds,dabunderrs,chisqFile)

chisqI = interp1d(Lps,chisqs,kind='cubic',fill_value='extrapolate')
x = np.arange(Lps[0],Lps[-1],(Lps[-1]-Lps[0])/100.)
chisqIs=chisqI(x)
plt.plot(x,chisqIs-np.min(chisqIs))
plt.xlabel("Lp (km)")
plt.ylabel('$\Delta\chi^2$')
plt.plot([0,Lps[-1]],[6.63,6.63],"--",color='0.8',label='99% confidence limit')
plt.plot([0,Lps[-1]],[1,1],":",color='0.8',label='$1\sigma$ confidence limit')
plt.plot(Lps,chisqs-np.min(chisqIs),'ko')
plt.xscale('log')
plt.xlim([Lps[0],Lps[-1]])
plt.ylim(-1,np.max(chisqIs-np.min(chisqIs)))

plt.show(block=False)                                                            
input("Press enter to exit...")
